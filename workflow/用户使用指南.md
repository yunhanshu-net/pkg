# AI工作流编排语言 - 用户使用指南

## 简介

AI工作流编排语言是一个基于Go语法的领域特定语言(DSL)，专门用于编写和执行AI工作流。它支持中文变量名、模板系统、条件分支、元数据配置等特性，让工作流的编写更加直观和高效。

## 快速开始

### 基本结构

每个工作流文件包含三个主要部分：

```go
// 1. 输入变量定义
var input = map[string]interface{}{
    "用户名": "张三",
    "手机号": 13800138000,
}

// 2. 工作流步骤定义
step1 = beiluo.test1.devops.devops_script_create(
    username: string "用户名",
    phone: int "手机号"
) -> (
    workId: string "工号",
    username: string "用户名", 
    err: error "是否失败"
);

step2 = beiluo.test1.crm.crm_interview_schedule(
    username: string "用户名"
) -> (
    interviewTime: string "面试时间",
    interviewer: string "面试官名称", 
    err: error "是否失败"
);

// 3. 主执行逻辑
func main() {
    //desc: 开始用户注册和面试安排流程
    fmt.Println("开始用户注册和面试安排流程...")
    
    //desc: 创建用户账号，获取工号
    工号, 用户名, step1Err := step1(input["用户名"], input["手机号"])
    
    //desc: 检查用户创建是否成功
    if step1Err != nil {
        //desc: 用户创建失败，记录错误并退出
        step1.Printf("创建用户失败: %v", step1Err)
        return
    }
    
    //desc: 用户创建成功，记录成功日志
    step1.Printf("✅ 用户创建成功，工号: %s", 工号)
    
    //desc: 安排面试时间，联系面试官
    面试时间, 面试官名称, step2Err := step2(用户名)
    
    //desc: 检查面试安排是否成功
    if step2Err != nil {
        //desc: 面试安排失败，记录错误并退出
        step2.Printf("安排面试失败: %v", step2Err)
        return
    }
    
    //desc: 面试安排成功，记录详细信息
    step2.Printf("✅ 面试安排成功，时间: %s", 面试时间)
}
```

## 语法详解

### 1. 输入变量定义

定义工作流的输入参数：

```go
var input = map[string]interface{}{
    "项目名称": "my-project",
    "版本号": "v1.0.0",
    "环境": "production",
    "是否发布": true,
}
```

**支持的数据类型**：
- `string` - 字符串
- `int` - 整数
- `bool` - 布尔值
- `float` - 浮点数

### 2. 步骤描述

为每个步骤添加详细的说明，让工作流更易理解：

```go
func main() {
    //desc: 开始订单处理流程
    fmt.Println("开始订单处理流程...")
    
    //desc: 验证订单信息，检查订单是否有效
    验证结果, step1Err := step1(input["订单号"], input["金额"]){retry:2, timeout:3000}
    
    //desc: 检查订单验证结果
    if step1Err != nil {
        //desc: 订单验证失败，记录错误并退出
        step1.Printf("订单验证失败: %v", step1Err)
        return
    }
    
    //desc: 根据验证结果决定后续流程
    if 验证结果 {
        //desc: 订单验证通过，开始处理支付
        fmt.Println("订单验证通过，开始处理支付...")
        
        //desc: 处理支付流程，调用支付接口
        支付流水号, step2Err := step2(input["订单号"], input["金额"]){retry:3, timeout:5000, priority:"high"}
        
        //desc: 检查支付是否成功
        if step2Err != nil {
            //desc: 支付失败，记录错误并退出
            step2.Printf("支付失败: %v", step2Err)
            return
        }
        
        //desc: 支付成功，记录流水号
        fmt.Printf("订单处理完成，支付流水号: %s\n", 支付流水号)
    } else {
        //desc: 订单验证失败，流程结束
        step1.Printf("订单验证失败")
        fmt.Println("订单验证失败，流程结束")
    }
}
```

**描述语法说明**：
- 使用 `//desc: 描述内容` 格式为下一个语句添加描述
- 描述信息会存储在解析结果的 `Desc` 字段中
- 支持所有类型的语句：`function-call`、`if`、`print`、`var`、`return` 等
- 支持嵌套语句的描述
- 描述信息可以用于界面渲染，让用户清楚了解每个步骤的作用

### 3. 工作流步骤定义

#### 静态工作流（用例ID引用）

```go
step1 = beiluo.test1.devops.git_push[用例001] -> (err 是否失败);
step2 = beiluo.test1.devops.deploy_test[用例002] -> (int cost, err 是否失败);
```

**特点**：
- 使用 `[用例ID]` 引用预定义的用例
- 参数从用例中自动获取
- 适合标准化的流程

#### 动态工作流（参数传递）

```go
step1 = beiluo.test1.devops.devops_script_create(
    username: string "用户名",
    phone: int "手机号"
) -> (
    workId: string "工号",
    username: string "用户名", 
    err: error "是否失败"
);

step2 = beiluo.test1.crm.crm_interview_schedule(
    username: string "用户名"
) -> (
    interviewTime: string "面试时间",
    interviewer: string "面试官名称", 
    err: error "是否失败"
);
```

**特点**：
- 使用 `参数名: 类型 "描述"` 定义输入参数
- 使用 `-> (参数名: 类型 "描述")` 定义输出参数
- 支持多行格式，提高可读性
- 英文参数名便于API调用，中文描述便于理解
- 支持参数动态传递

### 3. 主执行逻辑

#### 函数调用

```go
func main() {
    // 基本函数调用
    工号, 用户名, step1Err := step1(input["用户名"], input["手机号"])
    
    // 带元数据的函数调用
    面试时间, 面试官名称, step2Err := step2(用户名){retry:3, timeout:5000, priority:"high"}
    
    // 纯函数调用（无返回值）
    step3(面试官名称){retry:1, timeout:2000, async:true}
}
```

#### 条件判断

```go
func main() {
    工号, 用户名, step1Err := step1(input["用户名"], input["手机号"])
    
    if step1Err != nil {
        step1.Printf("创建用户失败: %v", step1Err)
        return
    }
    
    // 嵌套条件
    if 工号 != "" {
        面试时间, 面试官名称, step2Err := step2(用户名)
        if step2Err != nil {
            step2.Printf("安排面试失败: %v", step2Err)
            return
        }
    }
}
```

#### 变量赋值

```go
func main() {
    // 字符串赋值
    通知信息 := `你收到了:{{用户名}},时间：{{面试时间}}的面试安排，请关注`
    
    // 状态赋值
    状态 := "已完成"
    
    // 计算赋值
    总耗时 := 开始时间 + 处理时间
}
```

## 完整示例

### 示例1：静态工作流 - 代码发布流程

```go
var input = map[string]interface{}{
    "项目名称": "my-project",
    "版本号": "v1.2.0",
    "发布环境": "production",
}

// 静态工作流步骤定义
step1 = beiluo.test1.devops.git_push[用例001] -> (err 是否失败);
step2 = beiluo.test1.devops.build_image[用例002] -> (string 镜像ID, err 是否失败);
step3 = beiluo.test1.devops.deploy_service[用例003] -> (string 服务地址, err 是否失败);
step4 = beiluo.test1.devops.run_tests[用例004] -> (int 测试通过率, err 是否失败);
step5 = beiluo.test1.devops.send_notification[用例005] -> (err 是否失败);

func main() {
    fmt.Println("🚀 开始代码发布流程...")
    
    // 1. 推送代码到仓库
    fmt.Println("📤 推送代码到仓库...")
    step1Err := step1()
    if step1Err != nil {
        step1.Printf("❌ 代码推送失败: %v", step1Err)
        return
    }
    fmt.Println("✅ 代码推送成功")
    
    // 2. 构建Docker镜像
    fmt.Println("🐳 构建Docker镜像...")
    镜像ID, step2Err := step2()
    if step2Err != nil {
        step2.Printf("❌ 镜像构建失败: %v", step2Err)
        return
    }
    fmt.Printf("✅ 镜像构建成功，ID: %s\n", 镜像ID)
    
    // 3. 部署服务
    fmt.Println("🚀 部署服务到生产环境...")
    服务地址, step3Err := step3()
    if step3Err != nil {
        step3.Printf("❌ 服务部署失败: %v", step3Err)
        return
    }
    fmt.Printf("✅ 服务部署成功，地址: %s\n", 服务地址)
    
    // 4. 运行自动化测试
    fmt.Println("🧪 运行自动化测试...")
    测试通过率, step4Err := step4()
    if step4Err != nil {
        step4.Printf("❌ 测试运行失败: %v", step4Err)
        return
    }
    fmt.Printf("✅ 测试完成，通过率: %d%%\n", 测试通过率)
    
    // 5. 发送通知
    if 测试通过率 >= 90 {
        fmt.Println("📧 发送成功通知...")
        step5Err := step5()
        if step5Err != nil {
            step5.Printf("⚠️ 通知发送失败: %v", step5Err)
        } else {
            step5.Printf("✅ 通知发送成功")
        }
    }
    
    fmt.Println("🎉 代码发布流程完成！")
}
```

### 示例2：动态工作流 - 用户注册和面试安排

```go
var input = map[string]interface{}{
    "用户名": "张三",
    "手机号": 13800138000,
    "邮箱": "zhangsan@example.com",
    "部门": "技术部",
    "职位": "高级工程师",
}

// 动态工作流步骤定义
step1 = beiluo.test1.devops.devops_script_create(string 用户名, int 手机号, string 邮箱, string 部门) -> (string 工号, string 用户名, string 部门, err 是否失败);
step2 = beiluo.test1.crm.crm_interview_schedule(string 用户名, string 部门, string 职位) -> (string 面试时间, string 面试官名称, string 面试地点, err 是否失败);
step3 = beiluo.test1.notification.send_email(string 邮箱, string 主题, string 内容) -> (err 是否失败);
step4 = beiluo.test1.notification.send_sms(int 手机号, string 内容) -> (err 是否失败);
step5 = beiluo.test1.crm.crm_create_candidate(string 工号, string 用户名, string 部门, string 职位) -> (string 候选人ID, err 是否失败);

func main() {
    fmt.Println("👤 开始用户注册和面试安排流程...")
    
    // 1. 创建用户账号
    fmt.Println("📝 创建用户账号...")
    工号, 用户名, 部门, step1Err := step1(input["用户名"], input["手机号"], input["邮箱"], input["部门"]){retry:3, timeout:10000, priority:"critical"}
    if step1Err != nil {
        step1.Printf("❌ 用户创建失败: %v", step1Err)
        return
    }
    fmt.Printf("✅ 用户创建成功，工号: %s，部门: %s\n", 工号, 部门)
    
    // 2. 安排面试
    fmt.Println("📅 安排面试...")
    面试时间, 面试官名称, 面试地点, step2Err := step2(用户名, 部门, input["职位"]){retry:2, timeout:5000, priority:"high", async:true}
    if step2Err != nil {
        step2.Printf("❌ 面试安排失败: %v", step2Err)
        return
    }
    fmt.Printf("✅ 面试安排成功，时间: %s，面试官: %s，地点: %s\n", 面试时间, 面试官名称, 面试地点)
    
    // 3. 创建候选人记录
    fmt.Println("📋 创建候选人记录...")
    候选人ID, step5Err := step5(工号, 用户名, 部门, input["职位"]){retry:1, timeout:3000, priority:"normal"}
    if step5Err != nil {
        step5.Printf("⚠️ 候选人记录创建失败: %v", step5Err)
        // 不中断流程，继续执行
    } else {
        step5.Printf("✅ 候选人记录创建成功，ID: %s", 候选人ID)
    }
    
    // 4. 发送邮件通知
    fmt.Println("📧 发送邮件通知...")
    邮件主题 := `面试安排通知 - {{用户名}}`
    邮件内容 := `亲爱的 {{用户名}}，

您好！

您的面试已安排成功，详情如下：
- 工号：{{工号}}
- 部门：{{部门}}
- 面试时间：{{面试时间}}
- 面试官：{{面试官名称}}
- 面试地点：{{面试地点}}

请准时参加面试，祝您面试顺利！

此致
敬礼！`
    
    step3Err := step3(input["邮箱"], 邮件主题, 邮件内容){retry:2, timeout:5000, priority:"normal"}
    if step3Err != nil {
        step3.Printf("⚠️ 邮件发送失败: %v", step3Err)
    } else {
        step3.Printf("✅ 邮件发送成功")
    }
    
    // 5. 发送短信通知
    fmt.Println("📱 发送短信通知...")
    短信内容 := `【面试通知】{{用户名}}，您的面试已安排在{{面试时间}}，地点：{{面试地点}}，请准时参加。`
    
    step4Err := step4(input["手机号"], 短信内容){retry:1, timeout:3000, priority:"low"}
    if step4Err != nil {
        step4.Printf("⚠️ 短信发送失败: %v", step4Err)
    } else {
        step4.Printf("✅ 短信发送成功")
    }
    
    fmt.Println("🎉 用户注册和面试安排流程完成！")
}
```

### 示例3：混合工作流 - 订单处理和物流配送

```go
var input = map[string]interface{}{
    "订单号": "ORD-2024-001",
    "客户姓名": "李四",
    "客户电话": 13900139000,
    "收货地址": "北京市朝阳区xxx街道xxx号",
    "商品列表": []string{"商品A", "商品B", "商品C"},
    "支付方式": "微信支付",
    "配送方式": "标准配送",
}

// 混合工作流步骤定义
// 静态工作流 - 标准化的订单处理流程
step1 = beiluo.test1.order.validate_order[订单验证用例] -> (bool 验证结果, string 验证信息, err 是否失败);
step2 = beiluo.test1.order.create_order[订单创建用例] -> (string 订单ID, string 订单状态, err 是否失败);
step3 = beiluo.test1.payment.process_payment[支付处理用例] -> (string 支付流水号, string 支付状态, err 是否失败);

// 动态工作流 - 根据订单内容动态处理
step4 = beiluo.test1.inventory.check_stock(string 商品列表) -> (bool 库存充足, []string 缺货商品, err 是否失败);
step5 = beiluo.test1.inventory.reserve_stock(string 订单ID, []string 商品列表) -> (string 预留单号, err 是否失败);
step6 = beiluo.test1.warehouse.pick_goods(string 订单ID, string 预留单号) -> (string 拣货单号, []string 已拣商品, err 是否失败);
step7 = beiluo.test1.logistics.arrange_delivery(string 订单ID, string 收货地址, string 配送方式) -> (string 物流单号, string 预计送达时间, err 是否失败);
step8 = beiluo.test1.notification.send_order_notification(string 客户电话, string 订单号, string 物流单号) -> (err 是否失败);

func main() {
    fmt.Println("🛒 开始订单处理和物流配送流程...")
    
    // 1. 验证订单信息（静态工作流）
    fmt.Println("🔍 验证订单信息...")
    验证结果, 验证信息, step1Err := step1()
    if step1Err != nil {
        step1.Printf("❌ 订单验证失败: %v", step1Err)
        return
    }
    if !验证结果 {
        fmt.Printf("❌ 订单验证不通过: %s\n", 验证信息)
        return
    }
    fmt.Printf("✅ 订单验证通过: %s\n", 验证信息)
    
    // 2. 创建订单（静态工作流）
    fmt.Println("📝 创建订单...")
    订单ID, 订单状态, step2Err := step2()
    if step2Err != nil {
        step2.Printf("❌ 订单创建失败: %v", step2Err)
        return
    }
    fmt.Printf("✅ 订单创建成功，ID: %s，状态: %s\n", 订单ID, 订单状态)
    
    // 3. 检查库存（动态工作流）
    fmt.Println("📦 检查商品库存...")
    库存充足, 缺货商品, step4Err := step4(input["商品列表"]){retry:2, timeout:5000, priority:"high"}
    if step4Err != nil {
        step4.Printf("❌ 库存检查失败: %v", step4Err)
        return
    }
    if !库存充足 {
        fmt.Printf("❌ 库存不足，缺货商品: %v\n", 缺货商品)
        return
    }
    fmt.Println("✅ 库存检查通过")
    
    // 4. 预留库存（动态工作流）
    fmt.Println("🔒 预留商品库存...")
    预留单号, step5Err := step5(订单ID, input["商品列表"]){retry:3, timeout:8000, priority:"critical"}
    if step5Err != nil {
        step5.Printf("❌ 库存预留失败: %v", step5Err)
        return
    }
    fmt.Printf("✅ 库存预留成功，预留单号: %s\n", 预留单号)
    
    // 5. 处理支付（静态工作流）
    fmt.Println("💳 处理支付...")
    支付流水号, 支付状态, step3Err := step3()
    if step3Err != nil {
        step3.Printf("❌ 支付处理失败: %v", step3Err)
        return
    }
    fmt.Printf("✅ 支付处理成功，流水号: %s，状态: %s\n", 支付流水号, 支付状态)
    
    // 6. 拣货（动态工作流）
    fmt.Println("📋 开始拣货...")
    拣货单号, 已拣商品, step6Err := step6(订单ID, 预留单号){retry:2, timeout:10000, priority:"high"}
    if step6Err != nil {
        step6.Printf("❌ 拣货失败: %v", step6Err)
        return
    }
    fmt.Printf("✅ 拣货完成，拣货单号: %s，已拣商品: %v\n", 拣货单号, 已拣商品)
    
    // 7. 安排配送（动态工作流）
    fmt.Println("🚚 安排物流配送...")
    物流单号, 预计送达时间, step7Err := step7(订单ID, input["收货地址"], input["配送方式"]){retry:1, timeout:5000, priority:"normal"}
    if step7Err != nil {
        step7.Printf("❌ 配送安排失败: %v", step7Err)
        return
    }
    fmt.Printf("✅ 配送安排成功，物流单号: %s，预计送达: %s\n", 物流单号, 预计送达时间)
    
    // 8. 发送通知（动态工作流）
    fmt.Println("📱 发送订单通知...")
    step8Err := step8(input["客户电话"], input["订单号"], 物流单号){retry:1, timeout:3000, priority:"low"}
    if step8Err != nil {
        step8.Printf("⚠️ 通知发送失败: %v", step8Err)
    } else {
        step8.Printf("✅ 通知发送成功")
    }
    
    fmt.Println("🎉 订单处理和物流配送流程完成！")
}
```

### 示例4：复杂条件分支 - 智能客服处理

```go
var input = map[string]interface{}{
    "客户ID": "CUST-001",
    "问题类型": "技术问题",
    "问题描述": "无法登录系统",
    "紧急程度": "高",
    "客户等级": "VIP",
}

// 动态工作流步骤定义
step1 = beiluo.test1.crm.get_customer_info(string 客户ID) -> (string 客户姓名, string 客户等级, string 历史问题, err 是否失败);
step2 = beiluo.test1.ai.classify_question(string 问题描述, string 问题类型) -> (string 分类结果, string 置信度, []string 推荐解决方案, err 是否失败);
step3 = beiluo.test1.kb.search_solution(string 分类结果, string 问题描述) -> ([]string 解决方案, int 匹配度, err 是否失败);
step4 = beiluo.test1.ai.generate_response(string 问题描述, []string 解决方案, string 客户等级) -> (string 回复内容, string 回复类型, err 是否失败);
step5 = beiluo.test1.ticket.create_ticket(string 客户ID, string 问题描述, string 紧急程度) -> (string 工单号, string 工单状态, err 是否失败);
step6 = beiluo.test1.notification.send_response(string 客户ID, string 回复内容, string 回复类型) -> (err 是否失败);
step7 = beiluo.test1.crm.escalate_to_human(string 客户ID, string 工单号, string 问题描述) -> (string 处理人员, err 是否失败);

func main() {
    fmt.Println("🤖 开始智能客服处理流程...")
    
    // 1. 获取客户信息
    fmt.Println("👤 获取客户信息...")
    客户姓名, 客户等级, 历史问题, step1Err := step1(input["客户ID"]){retry:2, timeout:3000, priority:"normal"}
    if step1Err != nil {
        step1.Printf("❌ 获取客户信息失败: %v", step1Err)
        return
    }
    fmt.Printf("✅ 客户信息获取成功，姓名: %s，等级: %s\n", 客户姓名, 客户等级)
    
    // 2. AI问题分类
    fmt.Println("🧠 AI问题分类...")
    分类结果, 置信度, 推荐解决方案, step2Err := step2(input["问题描述"], input["问题类型"]){retry:1, timeout:5000, priority:"high", ai_model:"gpt-4"}
    if step2Err != nil {
        step2.Printf("❌ 问题分类失败: %v", step2Err)
        return
    }
    fmt.Printf("✅ 问题分类完成，结果: %s，置信度: %s\n", 分类结果, 置信度)
    
    // 3. 搜索解决方案
    fmt.Println("🔍 搜索解决方案...")
    解决方案, 匹配度, step3Err := step3(分类结果, input["问题描述"]){retry:2, timeout:4000, priority:"high"}
    if step3Err != nil {
        step3.Printf("❌ 解决方案搜索失败: %v", step3Err)
        return
    }
    fmt.Printf("✅ 解决方案搜索完成，匹配度: %d%%\n", 匹配度)
    
    // 4. 根据置信度和匹配度决定处理方式
    if 置信度 == "高" && 匹配度 >= 80 {
        // 高置信度且高匹配度 - 直接AI回复
        fmt.Println("🤖 生成AI自动回复...")
        回复内容, 回复类型, step4Err := step4(input["问题描述"], 解决方案, 客户等级){retry:1, timeout:6000, priority:"high", ai_model:"gpt-4"}
        if step4Err != nil {
            step4.Printf("❌ AI回复生成失败: %v", step4Err)
            return
        }
        fmt.Printf("✅ AI回复生成成功，类型: %s\n", 回复类型)
        
        // 发送回复
        fmt.Println("📤 发送AI回复...")
        step6Err := step6(input["客户ID"], 回复内容, 回复类型){retry:1, timeout:3000, priority:"normal"}
        if step6Err != nil {
            step6.Printf("⚠️ 回复发送失败: %v", step6Err)
        } else {
            step6.Printf("✅ 回复发送成功")
        }
        
    } else if 置信度 == "中" && 匹配度 >= 60 {
        // 中等置信度 - 创建工单并尝试AI回复
        fmt.Println("📋 创建工单...")
        工单号, 工单状态, step5Err := step5(input["客户ID"], input["问题描述"], input["紧急程度"]){retry:1, timeout:3000, priority:"normal"}
        if step5Err != nil {
            step5.Printf("❌ 工单创建失败: %v", step5Err)
            return
        }
        fmt.Printf("✅ 工单创建成功，工单号: %s，状态: %s\n", 工单号, 工单状态)
        
        // 尝试AI回复
        fmt.Println("🤖 尝试AI回复...")
        回复内容, 回复类型, step4Err := step4(input["问题描述"], 解决方案, 客户等级){retry:1, timeout:6000, priority:"medium", ai_model:"gpt-3.5"}
        if step4Err == nil {
            step4.Printf("✅ AI回复生成成功，类型: %s", 回复类型)
            
            // 发送回复
            step6Err := step6(input["客户ID"], 回复内容, 回复类型){retry:1, timeout:3000, priority:"normal"}
            if step6Err != nil {
                step6.Printf("⚠️ 回复发送失败: %v", step6Err)
            } else {
                step6.Printf("✅ 回复发送成功")
            }
        } else {
            step4.Printf("⚠️ AI回复生成失败，将转人工处理: %v", step4Err)
        }
        
    } else {
        // 低置信度或低匹配度 - 直接转人工处理
        fmt.Println("👨‍💼 转人工处理...")
        
        // 创建工单
        工单号, 工单状态, step5Err := step5(input["客户ID"], input["问题描述"], input["紧急程度"]){retry:1, timeout:3000, priority:"high"}
        if step5Err != nil {
            step5.Printf("❌ 工单创建失败: %v", step5Err)
            return
        }
        fmt.Printf("✅ 工单创建成功，工单号: %s，状态: %s\n", 工单号, 工单状态)
        
        // 升级到人工处理
        处理人员, step7Err := step7(input["客户ID"], 工单号, input["问题描述"]){retry:1, timeout:2000, priority:"high"}
        if step7Err != nil {
            step7.Printf("❌ 人工处理分配失败: %v", step7Err)
            return
        }
        fmt.Printf("✅ 已分配给处理人员: %s\n", 处理人员)
    }
    
    fmt.Println("🎉 智能客服处理流程完成！")
}
```

## 高级特性

### 1. 模板系统

支持 `{{变量名}}` 模板语法：

```go
// 基本模板
通知信息 := `你收到了:{{用户名}},时间：{{面试时间}}的面试安排，请关注`

// 复杂模板
报告内容 := `项目: {{项目名称}}
版本: {{版本号}}
状态: {{状态}}
负责人: {{负责人}}`
```

**模板变量来源**：
- 输入变量：`{{用户名}}`
- 函数返回值：`{{工号}}`, `{{面试时间}}`
- 步骤输出：`{{step1.工号}}`

### 2. 元数据配置

在函数调用后添加元数据配置：

```go
// 重试和超时配置
工号, 用户名, step1Err := step1(input["用户名"], input["手机号"]){retry:3, timeout:5000}

// 优先级和异步配置
面试时间, 面试官名称, step2Err := step2(用户名){priority:"high", async:true}

// 调试和模式配置
step3(面试官名称){debug:true, mode:"production", log_level:"info"}
```

**支持的元数据类型**：
- **数字**: `retry:3`, `timeout:5000`
- **布尔值**: `async:true`, `debug:false`
- **字符串**: `priority:"high"`, `mode:"production"`

### 3. 变量自动重命名

解析器会自动处理变量名冲突：

```go
// 原始代码
工号, 用户名, err := step1(input["用户名"], input["手机号"])
面试时间, 面试官名称, err := step2(用户名)  // err重复了

// 解析器自动重命名为：
工号, 用户名, step1Err := step1(input["用户名"], input["手机号"])
面试时间, 面试官名称, step2Err := step2(用户名)
```

### 4. 中文支持

完全支持中文变量名和注释：

```go
func main() {
    // 创建用户
    工号, 用户名, 创建错误 := step1(input["用户名"], input["手机号"])
    
    if 创建错误 != nil {
        step1.Printf("创建用户失败: %v", 创建错误)
        return
    }
    
    // 安排面试
    面试时间, 面试官名称, 安排错误 := step2(用户名)
    
    if 安排错误 != nil {
        step2.Printf("安排面试失败: %v", 安排错误)
        return
    }
}
```

## 最佳实践

### 1. 命名规范

```go
// 推荐：使用有意义的变量名
工号, 用户名, 创建错误 := step1(input["用户名"], input["手机号"])

// 不推荐：使用无意义的变量名
a, b, c := step1(input["用户名"], input["手机号"])
```

### 2. 错误处理

```go
// 推荐：每个步骤都检查错误
工号, 用户名, step1Err := step1(input["用户名"], input["手机号"])
if step1Err != nil {
    step1.Printf("步骤1失败: %v", step1Err)
    return
}

// 不推荐：忽略错误
工号, 用户名, _ := step1(input["用户名"], input["手机号"])
```

### 3. 元数据配置

```go
// 推荐：根据步骤重要性配置元数据
// 关键步骤：高重试次数，长超时时间
工号, 用户名, step1Err := step1(input["用户名"], input["手机号"]){retry:5, timeout:10000, priority:"critical"}

// 非关键步骤：低重试次数，短超时时间
通知内容 := "处理完成"
step3Err := step3(input["邮箱"], 通知内容){retry:1, timeout:2000, priority:"low"}
```

### 4. 模板使用

```go
// 推荐：使用模板提高可读性
通知信息 := `用户 {{用户名}} 的工号 {{工号}} 已创建成功，面试时间：{{面试时间}}`

// 不推荐：字符串拼接
通知信息 := "用户 " + 用户名 + " 的工号 " + 工号 + " 已创建成功，面试时间：" + 面试时间
```

## 常见问题

### Q: 如何处理变量名冲突？

A: 解析器会自动重命名冲突的变量名，特别是 `err` 变量会自动重命名为 `step1Err`, `step2Err` 等。

### Q: 元数据配置是必须的吗？

A: 不是必须的，元数据配置是可选的。如果不配置，函数调用会使用默认配置。

### Q: 支持哪些数据类型？

A: 支持 `string`, `int`, `bool`, `float` 等基本类型，以及 `err` 错误类型。

### Q: 如何调试工作流？

A: 可以在元数据中添加 `debug:true` 来启用调试模式，或者使用 `fmt.Printf` 输出调试信息。

### Q: 静态工作流和动态工作流有什么区别？

A: 
- **静态工作流**：使用 `[用例ID]` 引用预定义用例，参数从用例中获取，适合标准化流程
- **动态工作流**：使用 `(类型 参数名)` 定义参数，支持参数动态传递，适合灵活的业务场景

## 总结

AI工作流编排语言提供了简洁而强大的语法来编写工作流，支持中文变量名、模板系统、元数据配置等特性，让工作流的编写更加直观和高效。通过合理使用这些特性，可以编写出清晰、可维护的工作流代码。