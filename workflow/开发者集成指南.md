# AI工作流编排语言解析器 - 开发者集成指南

## 简介

本文档面向服务端开发者，介绍如何集成和使用AI工作流编排语言解析器。解析器将工作流代码解析为结构化的AST，为执行引擎提供完整的工作流信息。

## 核心架构

### 解析器设计理念

解析器采用"简单就是美"的设计理念：

1. **按行解析**: 直接按行读取，避免复杂的词法分析
2. **符号分隔**: 使用 `=`, `->`, `:=` 等符号进行分隔
3. **字符串操作**: 基于字符串操作，简单直观
4. **功能完整**: 在简单的基础上实现所有必需功能

### 核心组件

```
SimpleParser
├── ParseWorkflow()           # 主解析入口
├── parseInputVars()          # 解析输入变量
├── parseStep()               # 解析步骤定义
├── parseMainFunction()       # 解析主函数
├── parseStatement()          # 解析语句
├── parseArguments()          # 解析函数参数
├── parseMetadata()           # 解析元数据
└── parseReturnVariables()    # 解析返回变量
```

## 数据结构

### 核心结构体

#### SimpleParseResult - 解析结果

```go
type SimpleParseResult struct {
    Success   bool                    // 解析是否成功
    InputVars map[string]interface{} // 输入变量
    Steps     []SimpleStep           // 工作流步骤
    MainFunc  *SimpleMainFunc        // 主函数
    Variables map[string]VariableInfo // 变量映射表
    Error     string                 // 错误信息
}
```

#### SimpleStatement - 语句

```go
type SimpleStatement struct {
    Type       string                 // 语句类型
    Content    string                 // 语句内容
    LineNumber int                    // 行号
    Children   []*SimpleStatement     // 子语句（嵌套）
    Condition  string                 // 条件表达式
    Function   string                 // 函数名
    Args       []*ArgumentInfo        // 输入参数
    Returns    []*ArgumentInfo        // 输出参数
    Metadata   map[string]interface{} // 元数据配置
    Status     StatementStatus        // 执行状态
    RetryCount int                    // 重试次数
    Desc       string                 // 步骤描述信息
}
```

#### ArgumentInfo - 参数信息

```go
type ArgumentInfo struct {
    Value      string `json:"value"`       // 参数值
    Type       string `json:"type"`        // 参数类型
    IsVariable bool   `json:"is_variable"` // 是否为变量引用
    IsLiteral  bool   `json:"is_literal"`  // 是否为字面量
    IsInput    bool   `json:"is_input"`    // 是否为输入参数
    Source     string `json:"source"`      // 来源
    LineNum    int    `json:"line_num"`    // 定义行号
}
```

#### ParameterInfo - 参数定义信息

```go
type ParameterInfo struct {
    Name string `json:"name"` // 参数名（英文代码名）
    Type string `json:"type"` // 参数类型
    Desc string `json:"desc"` // 参数描述（中文）
}
```

#### SimpleStep - 工作流步骤

```go
type SimpleStep struct {
    Name        string           `json:"name"`         // 步骤名称
    Function    string           `json:"function"`     // 函数名
    InputParams []*ParameterInfo `json:"input_params"` // 输入参数定义
    OutputParams []*ParameterInfo `json:"output_params"` // 输出参数定义
    LineNumber  int              `json:"line_number"`  // 定义行号
}
```

#### VariableInfo - 变量信息

```go
type VariableInfo struct {
    Name    string // 变量名
    Type    string // 变量类型
    Source  string // 来源函数名
    LineNum int    // 定义行号
    IsInput bool   // 是否来自input
}
```

## API 使用

### 基本用法

```go
package main

import (
    "fmt"
    "github.com/yunhanshu-net/pkg/workflow"
)

func main() {
    // 工作流代码
    code := `
var input = map[string]interface{}{
    "用户名": "张三",
    "手机号": 13800138000,
}

step1 = beiluo.test1.devops.devops_script_create(username: string "用户名", phone: int "手机号") -> (workId: string "工号", username: string "用户名", err: error "是否失败");

func main() {
    //desc: 开始用户注册流程
    sys.Println("开始用户注册流程...")
    
    //desc: 创建用户账号，获取工号
    工号, 用户名, step1Err := step1(input["用户名"], input["手机号"]){retry:3, timeout:5000}
    
    //desc: 检查用户创建是否成功
    if step1Err != nil {
        //desc: 用户创建失败，记录错误并退出
        step1.Printf("创建用户失败: %v", step1Err)
        return
    }
    
    //desc: 用户创建成功，记录成功日志
    step1.Printf("✅ 用户创建成功，工号: %s", 工号)
}
`

    // 创建解析器
    parser := workflow.NewSimpleParser()
    
    // 解析工作流
    result := parser.ParseWorkflow(code)
    
    // 检查解析结果
    if !result.Success {
        sys.Printf("解析失败: %s", result.Error)
        return
    }
    
    // 使用解析结果
    processWorkflow(result)
}
```

### 解析结果处理

```go
func processWorkflow(result *workflow.SimpleParseResult) {
    // 1. 处理输入变量
    sys.Println("输入变量:")
    for key, value := range result.InputVars {
        sys.Printf("  %s: %v\n", key, value)
    }
    
    // 2. 处理工作流步骤
    sys.Println("工作流步骤:")
    for i, step := range result.Steps {
        sys.Printf("  %d. %s - %s\n", i+1, step.Name, step.Function)
        
        // 显示输入参数定义
        if len(step.InputParams) > 0 {
            sys.Printf("    输入参数:\n")
            for _, param := range step.InputParams {
                sys.Printf("      %s: %s \"%s\"\n", param.Name, param.Type, param.Desc)
            }
        }
        
        // 显示输出参数定义
        if len(step.OutputParams) > 0 {
            sys.Printf("    输出参数:\n")
            for _, param := range step.OutputParams {
                sys.Printf("      %s: %s \"%s\"\n", param.Name, param.Type, param.Desc)
            }
        }
    }
    
    // 3. 处理主函数语句
    sys.Println("主函数语句:")
    processStatements(result.MainFunc.Statements, 0)
    
    // 4. 处理步骤描述信息
    sys.Println("步骤描述信息:")
    for i, stmt := range result.MainFunc.Statements {
        if stmt.Desc != "" {
            sys.Printf("  语句 %d: %s\n", i+1, stmt.Desc)
        }
    }
    
    // 4. 处理变量映射
    sys.Println("变量映射:")
    for varName, info := range result.Variables {
        sys.Printf("  %s: %s (来源: %s)\n", varName, info.Type, info.Source)
    }
}

func processStatements(statements []*workflow.SimpleStatement, depth int) {
    indent := strings.Repeat("  ", depth)
    
    for i, stmt := range statements {
        // 显示语句信息和描述
        if stmt.Desc != "" {
            sys.Printf("%s%d. [%s] %s - %s\n", indent, i+1, stmt.Type, stmt.Desc, stmt.Content)
        } else {
            sys.Printf("%s%d. [%s] %s\n", indent, i+1, stmt.Type, stmt.Content)
        }
        
        // 处理函数调用
        if stmt.Type == "function-call" {
            processFunctionCall(stmt)
        }
        
        // 递归处理子语句
        if len(stmt.Children) > 0 {
            processStatements(stmt.Children, depth+1)
        }
    }
}

func processFunctionCall(stmt *workflow.SimpleStatement) {
    sys.Printf("    函数: %s\n", stmt.Function)
    
    // 处理输入参数
    if len(stmt.Args) > 0 {
        sys.Printf("    输入参数:\n")
        for j, arg := range stmt.Args {
            sys.Printf("      %d. %s (%s)\n", j+1, arg.Value, arg.Type)
        }
    }
    
    // 处理输出参数
    if len(stmt.Returns) > 0 {
        sys.Printf("    输出参数:\n")
        for j, ret := range stmt.Returns {
            sys.Printf("      %d. %s (%s)\n", j+1, ret.Value, ret.Type)
        }
    }
    
    // 处理元数据
    if len(stmt.Metadata) > 0 {
        sys.Printf("    元数据:\n")
        for key, value := range stmt.Metadata {
            sys.Printf("      %s: %v\n", key, value)
        }
    }
}
```

## 语句类型详解

### 1. function-call - 函数调用

```go
// 解析结果
stmt := &SimpleStatement{
    Type:       "function-call",
    Function:   "step1",
    Args:       []ArgumentInfo{...},  // 输入参数
    Returns:    []ArgumentInfo{...},  // 输出参数
    Metadata:   map[string]interface{}{...}, // 元数据
}
```

**支持的语法**：
- `工号, 用户名, step1Err := step1(input["用户名"], input["手机号"])`
- `step1(input["用户名"], input["手机号"]){retry:3, timeout:5000}`
- `err = step2(用户名)`

### 2. if - 条件判断

```go
// 解析结果
stmt := &SimpleStatement{
    Type:      "if",
    Condition: "step1Err != nil",
    Children:  []SimpleStatement{...}, // 子语句
}
```

**支持的语法**：
- `if step1Err != nil { ... }`
- `if 工号 != "" { ... }`

### 3. var - 变量赋值

```go
// 解析结果
stmt := &SimpleStatement{
    Type: "var",
    Content: "通知信息 := `你收到了:{{用户名}}的面试安排`",
}
```

**支持的语法**：
- `通知信息 := "字符串"`
- `状态 := "已完成"`

### 4. print - 打印语句

```go
// 解析结果
stmt := &SimpleStatement{
    Type: "print",
    Content: "step1.Printf(\"创建用户失败: %v\", step1Err)",
}
```

**支持的语法**：
- `sys.Printf("...", ...)`
- `sys.Println("...")`

### 5. return - 返回语句

```go
// 解析结果
stmt := &SimpleStatement{
    Type: "return",
    Content: "return",
}
```

## 参数解析详解

### 步骤参数定义解析

```go
// 输入: username: string "用户名", phone: int "手机号"
// 解析结果:
inputParams := []*ParameterInfo{
    {
        Name: "username",
        Type: "string", 
        Desc: "用户名",
    },
    {
        Name: "phone",
        Type: "int",
        Desc: "手机号",
    },
}
```

### 函数调用参数解析

```go
// 输入: step1(input["用户名"], input["手机号"])
// 解析结果:
args := []*ArgumentInfo{
    {
        Value:      "input[\"用户名\"]",
        Type:       "input",
        IsInput:    true,
        IsVariable: true,
        Source:     "input",
    },
    {
        Value:      "input[\"手机号\"]",
        Type:       "input", 
        IsInput:    true,
        IsVariable: true,
        Source:     "input",
    },
}
```

### 输出参数解析

```go
// 输入: 工号, 用户名, step1Err := step1(...)
// 解析结果:
returns := []*ArgumentInfo{
    {
        Value:      "工号",
        Type:       "string",
        IsVariable: true,
        Source:     "step1",
    },
    {
        Value:      "用户名",
        Type:       "string",
        IsVariable: true,
        Source:     "step1",
    },
    {
        Value:      "step1Err", // 自动重命名
        Type:       "err",
        IsVariable: true,
        Source:     "step1",
    },
}
```

### 元数据解析

```go
// 输入: {retry:3, timeout:5000, priority:"high"}
// 解析结果:
metadata := map[string]interface{}{
    "retry":    3,           // int
    "timeout":  5000,        // int
    "priority": "high",      // string
}
```

## 错误处理

### 解析错误

```go
result := parser.ParseWorkflow(code)
if !result.Success {
    switch {
    case strings.Contains(result.Error, "语法错误"):
        // 处理语法错误
    case strings.Contains(result.Error, "类型错误"):
        // 处理类型错误
    default:
        // 处理其他错误
    }
}
```

### 常见错误类型

1. **语法错误**: 代码格式不正确
2. **类型错误**: 参数类型不匹配
3. **变量未定义**: 使用了未定义的变量
4. **函数未定义**: 调用了未定义的函数

## 性能优化

### 解析性能

- **简单高效**: 基于行解析和符号分隔，性能优异
- **内存友好**: 低内存占用，适合大规模工作流
- **解析快速**: 直接字符串操作，无复杂词法分析开销

### 内存使用

```go
// 建议：及时释放不需要的解析结果
func processWorkflow(result *workflow.SimpleParseResult) {
    // 处理完成后
    result = nil // 帮助GC
}
```

## 执行引擎集成

### 类型回调机制

工作流执行引擎支持基于语句类型的回调机制，允许外部业务逻辑注入：

```go
// 创建类型回调执行器
callbackExecutor := workflow.NewTypeCallbackExecutor()

// 注册 function-call 回调
callbackExecutor.RegisterType("function-call", func(ctx *workflow.StatementContext) *workflow.StatementCallbackResult {
    // 业务逻辑：调用实际的HTTP接口
    sys.Printf("执行函数调用: %s\n", ctx.Statement.Function)
    
    // 模拟HTTP调用
    result := callHTTPAPI(ctx.Statement.Function, ctx.Statement.Args)
    
    return &workflow.StatementCallbackResult{
        Success:    true,
        OutputArgs: result,
    }
})

// 注册 if 回调
callbackExecutor.RegisterType("if", func(ctx *workflow.StatementContext) *workflow.StatementCallbackResult {
    // 业务逻辑：评估条件
    condition := evaluateCondition(ctx.Statement.Condition, ctx.Variables)
    
    return &workflow.StatementCallbackResult{
        Success:    true,
        OutputArgs: []interface{}{condition},
    }
})

// 创建执行器并注册回调
executor := workflow.NewWorkflowExecutorWithCallback(callbackExecutor)

// 执行工作流
result := executor.ExecuteWorkflow(parseResult)
```

### 回调上下文

```go
type StatementContext struct {
    Statement *SimpleStatement        // 当前语句
    InputVars map[string]interface{}  // 输入变量
    Variables map[string]interface{}  // 过程变量
    Returns   []*ArgumentInfo         // 期望的返回参数定义
    Metadata  map[string]interface{}  // 元数据
}
```

### 回调结果

```go
type StatementCallbackResult struct {
    Success    bool          // 是否成功
    Error      error         // 错误信息
    OutputArgs []interface{} // 回调函数返回的参数
}
```

## 扩展开发

### 添加新的语句类型

1. 在 `parseStatement` 中添加新的条件判断
2. 定义新的语句类型常量
3. 添加相应的解析逻辑

```go
// 示例：添加 switch 语句支持
if strings.HasPrefix(line, "switch") {
    return &SimpleStatement{
        Type: "switch",
        // ... 其他字段
    }
}
```

### 添加新的元数据类型

1. 在 `parseMetadata` 中添加新的类型推断
2. 支持复杂的数据结构

```go
// 示例：添加数组类型支持
if strings.HasPrefix(value, "[") && strings.HasSuffix(value, "]") {
    // 解析数组
    parsedValue = parseArray(value)
}
```

## 测试

### 单元测试

```go
func TestParser(t *testing.T) {
    code := `...`
    parser := workflow.NewSimpleParser()
    result := parser.ParseWorkflow(code)
    
    assert.True(t, result.Success)
    assert.Len(t, result.MainFunc.Statements, 3)
    // ... 更多断言
}
```

### 集成测试

```go
func TestIntegration(t *testing.T) {
    // 测试完整的工作流解析和执行
    code := loadWorkflowFromFile("test.workflow")
    result := parseAndExecute(code)
    assert.Equal(t, "success", result.Status)
}
```

## 最佳实践

### 1. 错误处理

```go
// 推荐：完整的错误处理
result := parser.ParseWorkflow(code)
if !result.Success {
    log.Errorf("解析失败: %s", result.Error)
    return fmt.Errorf("工作流解析失败: %w", errors.New(result.Error))
}
```

### 2. 资源管理

```go
// 推荐：及时释放资源
func processWorkflow(code string) error {
    parser := workflow.NewSimpleParser()
    result := parser.ParseWorkflow(code)
    defer func() {
        // 清理资源
        result = nil
    }()
    
    // 处理逻辑
    return nil
}
```

### 3. 日志记录

```go
// 推荐：记录解析过程
func parseWithLogging(code string) *workflow.SimpleParseResult {
    log.Info("开始解析工作流")
    result := parser.ParseWorkflow(code)
    
    if result.Success {
        log.Infof("解析成功，共 %d 个步骤", len(result.Steps))
    } else {
        log.Errorf("解析失败: %s", result.Error)
    }
    
    return result
}
```

## 总结

AI工作流编排语言解析器提供了简单而强大的API来解析工作流代码。通过合理使用解析结果，可以构建出功能完整的工作流执行引擎。解析器设计简洁，性能优异，易于扩展和维护。