# 工作流编排代码生成指南

## 概述

本文档用于指导大模型生成 AI 工作流编排代码。工作流编排语言支持静态工作流和动态工作流两种模式，通过简单的代码语法实现复杂的业务流程自动化。

**重要提醒：`//desc:` 描述注释是强制性的，每个步骤定义和主要语句都必须包含，不能省略。**

## 核心语法结构

### 1. 变量定义
```go
var input = {
    "参数名1": 值1,
    "参数名2": 值2,
    // 支持字符串、数字、布尔值等基本类型
}
```

### 2. 步骤定义
```go
//desc: 步骤描述（强制性）
步骤名 = 命名空间.模块.函数名(参数类型 参数名, ...) -> (返回名: 返回类型 "描述", ...) {元数据配置}
```

**重要：步骤定义不需要返回 `err` 类型，执行引擎会自动处理错误和日志。**

**注意：每个步骤定义前必须添加 `//desc:` 描述注释，这是强制性的。**

#### 元数据配置规则
- **超时配置**：`{timeout: 5000}` 表示5秒超时
- **重试配置**：`{retry: 3}` 表示失败时重试3次
- **异步配置**：`{async: true}` 表示异步执行
- **优先级配置**：`{priority: 10}` 表示优先级为10
- **调试配置**：`{debug: true}` 表示开启调试模式
- **AI模型**：`{ai_model: "gpt-4"}` 表示使用GPT-4模型
- **错误继续**：`{err_continue: true}` 表示出错时继续执行下一步，默认false（出错终止）

**重要：执行引擎会自动处理错误和日志，开发者只需专注于业务逻辑。**

#### err_continue 模式详解

`err_continue` 模式是工作流编排的重要特性，用于控制步骤执行失败时的行为：

**默认行为（err_continue: false 或不设置）**：
- 步骤执行失败时，工作流立即终止
- 需要手动检查每个步骤的错误状态
- 代码中包含大量的 `if err != nil { return }` 判断

**err_continue: true 模式**：
- 步骤执行失败时，工作流继续执行下一步
- 可以记录错误日志，但不中断流程
- 适用于非关键步骤或可选操作
- 大大简化错误处理代码

**使用场景**：
- 日志记录步骤：失败不影响主流程
- 通知发送步骤：失败不影响业务逻辑
- 数据备份步骤：失败不影响核心功能
- 可选的数据处理步骤

#### 代码对比示例

**传统模式（代码膨胀）**：
```go
//desc: 用户创建
step1 = user.service.create_user(username: string "用户名", email: string "邮箱") -> (userID: int "用户ID", err: error "是否失败")
//desc: 发送欢迎邮件
step2 = email.service.send_welcome(email: string "邮箱", userID: int "用户ID") -> (success: bool "是否成功", err: error "是否失败")
//desc: 记录用户日志
step3 = log.service.record_user_action(userID: int "用户ID", action: string "操作") -> (logID: int "日志ID", err: error "是否失败")

func main() {
    //desc: 创建用户
    用户ID := step1("张三", "zhangsan@example.com")
    
    //desc: 发送欢迎邮件
    邮件成功 := step2("zhangsan@example.com", 用户ID)
    
    //desc: 记录日志
    日志ID := step3(用户ID, "用户注册")
}
```

**执行引擎自动处理模式（极简代码）**：
```go
//desc: 用户创建
step1 = user.service.create_user(username: string "用户名", email: string "邮箱") -> (userID: int "用户ID")
//desc: 发送欢迎邮件（允许失败继续）
step2 = email.service.send_welcome(email: string "邮箱", userID: int "用户ID") -> (success: bool "是否成功") {err_continue: true}
//desc: 记录用户日志（允许失败继续）
step3 = log.service.record_user_action(userID: int "用户ID", action: string "操作") -> (logID: int "日志ID") {err_continue: true}

func main() {
    
    //desc: 创建用户（关键步骤，默认出错终止）
    用户ID := step1("张三", "zhangsan@example.com")
    
    //desc: 发送欢迎邮件（非关键步骤，允许失败继续）
    邮件成功 := step2("zhangsan@example.com", 用户ID)
    
    //desc: 记录用户日志（非关键步骤，允许失败继续）
    日志ID := step3(用户ID, "用户注册")
    
}
```

**优势对比**：
- **代码行数**：从 40+ 行减少到 15 行
- **错误处理**：完全由执行引擎自动处理
- **日志打印**：完全由执行引擎自动处理
- **可读性**：100% 专注于业务逻辑
- **维护性**：代码极简，易于理解和修改

### 3. 主函数
```go
func main() {
    //desc: 语句描述（强制性）
    // 工作流执行逻辑
}
```

**注意：主函数中的每个主要语句前必须添加 `//desc:` 描述注释，这是强制性的。**

**重要：主函数不需要处理错误和打印日志，执行引擎会自动处理。开发者只需专注于业务逻辑。**

## 动态工作流

动态工作流适用于需要根据输入参数动态调用的业务流程。

### 语法特点
- 步骤定义中包含完整的参数列表
- 主函数中调用步骤时需要传递具体参数
- 支持从 input 变量中获取参数值
- 适用于参数化的业务流程
- **每个步骤定义前必须添加 `//desc:` 描述注释（强制性）**

### 示例模板
```go
var input = {
    "参数名1": "值1",
    "参数名2": 值2,
    "参数名3": "值3"
}

//desc: 步骤描述1（允许失败继续）
step1 = 命名空间.模块.函数名(参数类型 参数名, 参数类型 参数名) -> (返回名1: 返回类型 "描述", 返回名2: 返回类型 "描述") {err_continue: true}
//desc: 步骤描述2（允许失败继续）
step2 = 命名空间.模块.函数名(参数类型 参数名) -> (返回名1: 返回类型 "描述", 返回名2: 返回类型 "描述") {err_continue: true}
//desc: 步骤描述3（默认出错终止）
step3 = 命名空间.模块.函数名(参数类型 参数名, 参数类型 参数名) -> (返回名: 返回类型 "描述")

func main() {
    //desc: 开始执行动态工作流
    
    //desc: 执行第一步，传递参数（允许失败继续）
    返回值1, 返回值2 := step1(input["参数名1"], input["参数名2"])
    
    //desc: 执行第二步，使用第一步的返回值（允许失败继续）
    返回值3, 返回值4 := step2(返回值1)
    
    //desc: 执行第三步，组合使用多个参数（默认出错终止）
    返回值5 := step3(返回值2, 返回值3)
    
    //desc: 流程完成
}
```

## 静态工作流

静态工作流适用于固定的业务流程，所有步骤和参数都是预定义的。

### 语法特点
- 步骤定义中使用 `[用例ID]` 引用预定义的用例
- 参数从用例中自动获取，无需在主函数中传递
- 适用于标准化的业务流程
- 用例ID用于标识预定义的测试用例或配置
- **每个步骤定义前必须添加 `//desc:` 描述注释（强制性）**

### 示例模板
```go
var input = {
    "项目名称": "my-project",
    "环境": "production",
    "版本": "v1.0.0"
}

//desc: 步骤描述1
step1 = 命名空间.模块.函数名[用例001] -> (返回名: 返回类型 "描述")
//desc: 步骤描述2
step2 = 命名空间.模块.函数名[用例002] -> (返回名: 返回类型 "描述")
//desc: 步骤描述3
step3 = 命名空间.模块.函数名[用例003] -> (返回名: 返回类型 "描述")

func main() {
    //desc: 开始执行业务流程
    
    //desc: 执行第一步
    result1 := step1()
    
    //desc: 执行第二步
    result2 := step2()
    
    //desc: 执行第三步
    result3 := step3()
    
    //desc: 流程完成
}
```

## 关键语法规则

### 1. 步骤定义规则
- 步骤名必须是有效的标识符
- 函数名使用点号分隔的命名空间格式：`命名空间.模块.函数名`
- 动态工作流：使用 `(参数列表)` 格式，如 `函数名(参数类型 参数名)`
- 静态工作流：使用 `[用例ID]` 格式，如 `函数名[用例001]`
- 参数类型支持：`string`, `int`, `float`, `bool` 等
- 参数名和返回名支持中文和英文
- **不需要返回 `err` 类型，执行引擎会自动处理错误**
- **每个步骤定义前必须添加 `//desc:` 描述注释（强制性）**
- **禁止使用 `var (step1 = ...)` 批量声明格式，必须逐个定义步骤**

### 2. 主函数规则
- 必须使用 `func main()` 定义
- **不需要检查错误，执行引擎会自动处理**
- **不需要打印日志，执行引擎会自动处理**
- **每个主要语句前必须添加 `//desc:` 描述注释（强制性）**
- **专注于业务逻辑，让执行引擎处理技术细节**

### 3. 条件判断规则
- 条件判断语句前必须添加 `//desc:` 注释说明判断逻辑
- 条件判断中的变量会自动声明，无需提前声明
- **条件判断中的步骤调用不需要错误处理，执行引擎会自动处理**
- 条件判断可以嵌套，但要注意变量作用域
- 示例：
  ```go
  //desc: 判断是否启用高级功能
  if 启用高级功能 {
      //desc: 执行高级功能
      高级结果 := step1(参数)
      // 处理高级结果
  }
  ```

### 4. 描述注释规则（强制性）
- **每个步骤定义前必须添加 `//desc: 描述内容`** - 这是强制性的，不能省略
- **每个主要语句前必须添加 `//desc: 描述内容`** - 这是强制性的，不能省略
- 描述内容要简洁明了，说明步骤的作用
- 描述内容支持中文
- 没有 `//desc:` 注释的步骤定义或语句将被视为不完整的代码

### 5. 变量使用规则
- 动态工作流：传递参数，如 `result, err := step1(input["参数名"])`
- 静态工作流：直接调用步骤，如 `result, err := step1()`
- 变量名支持中文和英文
- 错误变量会自动重命名避免冲突

## 元数据支持

### 超时控制
```go
result, err := step1(input["参数"]){timeout: 5000}  // 5秒超时
```

### 重试机制
```go
result, err := step1(input["参数"]){retry_count: 3}  // 重试3次
```

### 调试模式
```go
result, err := step1(input["参数"]){debug: true}  // 开启调试
```

### 组合使用
```go
result, err := step1(input["参数"]){timeout: 5000, retry_count: 2, debug: true}
```

## 常见业务场景模板

### 1. 用户注册流程（动态工作流）
```go
var input = {
    "用户名": "张三",
    "手机号": 13800138000,
    "邮箱": "zhangsan@example.com"
}

//desc: 创建用户账号
step1 = user.service.create_user(username: string "用户名", phone: int "手机号", email: string "邮箱") -> (userId: string "用户ID", username: string "用户名")
//desc: 发送验证邮件（允许失败继续）
step2 = user.service.send_verification(userId: string "用户ID", email: string "邮箱") -> (success: bool "是否成功") {err_continue: true}
//desc: 发送欢迎通知（允许失败继续）
step3 = notification.service.send_welcome(username: string "用户名", email: string "邮箱") -> (success: bool "是否成功") {err_continue: true}

func main() {
    //desc: 开始用户注册流程
    
    //desc: 创建用户账号
    用户ID, 用户名 := step1(input["用户名"], input["手机号"], input["邮箱"])
    
    //desc: 发送验证邮件（允许失败继续）
    验证成功 := step2(用户ID, input["邮箱"])
    
    //desc: 发送欢迎通知（允许失败继续）
    通知成功 := step3(用户名, input["邮箱"])
    
}
```

### 2. 静态工作流示例（DevOps发布流程）
```go
var input = {
    "项目名称": "my-project",
    "环境": "production",
    "版本": "v1.0.0"
}

//desc: 推送代码到远程仓库
step1 = beiluo.test1.devops.git_push[用例001] -> ()
//desc: 部署到测试环境
step2 = beiluo.test1.devops.deploy_test[用例002] -> (cost: int "成本")
//desc: 部署到生产环境
step3 = beiluo.test1.devops.deploy_prod[用例003] -> (msg: string "消息")
//desc: 发送部署完成通知（允许失败继续）
step4 = beiluo.test1.notify.send_notification[用例004] -> () {err_continue: true}

func main() {
    //desc: 开始执行发布流程
    
    //desc: 推送代码到远程仓库
    step1()
    
    //desc: 部署到测试环境
    cost := step2()
    
    //desc: 部署到生产环境
    msg := step3()
    
    //desc: 发送部署完成通知（允许失败继续）
    step4()
    
}
```

### 3. 订单处理流程
```go
var input = {
    "订单号": "ORD001",
    "用户ID": "USER001",
    "商品ID": "PROD001",
    "数量": 2
}

//desc: 验证订单信息
step1 = order.service.validate_order(orderId: string "订单ID", userId: string "用户ID", productId: string "商品ID", quantity: int "数量") -> (valid: bool "是否有效", message: string "消息")
//desc: 检查库存
step2 = inventory.service.check_stock(productId: string "商品ID", quantity: int "数量") -> (available: bool "是否有库存", stock: int "库存数量")
//desc: 处理支付
step3 = payment.service.process_payment(orderId: string "订单ID", amount: float "金额") -> (transactionId: string "交易ID", success: bool "是否成功")
//desc: 更新订单状态
step4 = order.service.update_status(orderId: string "订单ID", status: string "状态") -> (success: bool "是否成功")

func main() {
    //desc: 开始订单处理流程
    
    //desc: 验证订单信息
    有效, 消息 := step1(input["订单号"], input["用户ID"], input["商品ID"], input["数量"])
    
    if !有效 {
        return
    }
    
    //desc: 检查库存
    有库存, 库存数量 := step2(input["商品ID"], input["数量"])
    
    if !有库存 {
        return
    }
    
    //desc: 处理支付
    交易ID, 支付成功 := step3(input["订单号"], 100.0)
    
    if !支付成功 {
        return
    }
    
    //desc: 更新订单状态
    更新成功 := step4(input["订单号"], "已支付")
    
}
```

### 4. 数据同步流程
```go
var input = {
    "源数据库": "mysql://source",
    "目标数据库": "postgres://target",
    "表名": "users",
    "批次大小": 1000
}

//desc: 提取源数据
step1 = data.service.extract_data(sourceDb: string "源数据库", tableName: string "表名", batchSize: int "批次大小") -> (data: []map[string]interface{} "数据", count: int "数量")
//desc: 转换数据格式
step2 = data.service.transform_data(data: []map[string]interface{} "数据") -> (transformedData: []map[string]interface{} "转换后数据")
//desc: 加载到目标数据库
step3 = data.service.load_data(targetDb: string "目标数据库", tableName: string "表名", data: []map[string]interface{} "数据") -> (insertedCount: int "插入数量")
//desc: 验证同步结果
step4 = data.service.verify_sync(sourceDb: string "源数据库", targetDb: string "目标数据库", tableName: string "表名") -> (success: bool "是否成功", sourceCount: int "源数量", targetCount: int "目标数量")

func main() {
    //desc: 开始数据同步流程
    
    //desc: 提取源数据
    数据, 记录数 := step1(input["源数据库"], input["表名"], input["批次大小"])
    
    
    //desc: 转换数据格式
    转换后数据 := step2(数据)
    
    //desc: 加载到目标数据库
    插入数量 := step3(input["目标数据库"], input["表名"], 转换后数据)
    
    
    //desc: 验证同步结果
    验证成功, 源数量, 目标数量 := step4(input["源数据库"], input["目标数据库"], input["表名"])
    
    if !验证成功 {
        return
    }
    
}
```

### 5. 条件判断工作流示例（代码解析测试）
```go
var input = {
    "代码文件路径": "path/to/code/file.go",
    "解析规则版本": "v1.0",
    "是否启用高级解析": true,
    "输出格式": "json"
}

//desc: 读取代码文件
step1 = code.service.read_code_file(filePath: string "代码文件路径") -> (codeContent: string "代码内容")
//desc: 检查代码文件是否为空
step2 = code.service.check_code_empty(codeContent: string "代码内容") -> (isEmpty: bool "是否为空")
//desc: 选择解析规则
step3 = code.service.select_parsing_rule(ruleVersion: string "解析规则版本") -> (rule: string "解析规则")
//desc: 判断是否启用高级解析
step4 = code.service.is_advanced_parsing_enabled(isEnabled: bool "是否启用高级解析") -> (isAdvanced: bool "是否高级解析")
//desc: 基础代码解析
step5 = code.service.basic_parsing(codeContent: string "代码内容", rule: string "解析规则") -> (basicResult: map[string]interface{} "基础解析结果")
//desc: 高级代码解析
step6 = code.service.advanced_parsing(codeContent: string "代码内容", rule: string "解析规则") -> (advancedResult: map[string]interface{} "高级解析结果")
//desc: 合并解析结果
step7 = code.service.merge_results(basicResult: map[string]interface{} "基础解析结果", advancedResult: map[string]interface{} "高级解析结果", isAdvanced: bool "是否高级解析") -> (mergedResult: map[string]interface{} "合并结果")
//desc: 检查解析结果是否有效
step8 = code.service.check_result_validity(mergedResult: map[string]interface{} "合并结果") -> (isValid: bool "是否有效")
//desc: 转换输出格式
step9 = code.service.convert_output_format(result: map[string]interface{} "合并结果", outputFormat: string "输出格式") -> (output: string "最终输出")
//desc: 保存解析结果
step10 = code.service.save_result(output: string "最终输出") -> (success: bool "是否成功")
//desc: 发送解析完成通知（允许失败继续）
step11 = code.service.send_notification() -> () {err_continue: true}

func main() {
    //desc: 开始代码解析工作流
    
    //desc: 读取代码文件
    代码内容 := step1(input["代码文件路径"])
    
    //desc: 检查代码文件是否为空
    为空 := step2(代码内容)
    if 为空 {
        return
    }
    
    //desc: 选择解析规则
    解析规则 := step3(input["解析规则版本"])
    
    //desc: 判断是否启用高级解析
    高级解析 := step4(input["是否启用高级解析"])
    
    //desc: 基础代码解析
    基础解析结果 := step5(代码内容, 解析规则)
    
    //desc: 判断是否启用高级解析
    if 高级解析 {
        //desc: 高级代码解析
        高级解析结果 := step6(代码内容, 解析规则)
    }
    
    //desc: 合并解析结果
    合并结果 := step7(基础解析结果, 高级解析结果, 高级解析)
    
    //desc: 检查解析结果是否有效
    有效 := step8(合并结果)
    if !有效 {
        return
    }
    
    //desc: 转换输出格式
    最终输出 := step9(合并结果, input["输出格式"])
    
    //desc: 保存解析结果
    保存成功 := step10(最终输出)
    if !保存成功 {
        return
    }
    
    //desc: 发送解析完成通知（允许失败继续）
    step11()
    
}
```

### 6. 错误格式示例对比

**❌ 错误格式（禁止使用）：**
```go
// 错误1: 批量声明格式
var (
    step1 = beiluo.test1.devops.initialize_system(string 用户名, int 年龄) -> (string 系统ID, bool 初始化成功, err 是否失败);
    step2 = beiluo.test1.hr.create_employee_profile(string 用户名, string 部门) -> (string 员工编号, bool 创建成功, err 是否失败);
)

// 错误2: 旧格式返回值
step1 = beiluo.test1.devops.initialize_system(用户名: string "用户名", 年龄: int "年龄") -> (string 系统ID, bool 初始化成功, err 是否失败)

// 错误3: 使用fmt打印函数（已移除打印功能支持）

// 错误4: 条件判断缺少注释
if 条件变量 {
    // 缺少 //desc: 注释
}
```

**✅ 正确格式：**
```go
//desc: 初始化系统
step1 = beiluo.test1.devops.initialize_system(用户名: string "用户名", 年龄: int "年龄") -> (系统ID: string "系统ID", 初始化成功: bool "是否成功")

//desc: 创建员工档案
step2 = beiluo.test1.hr.create_employee_profile(用户名: string "用户名", 部门: string "部门") -> (员工编号: string "员工编号", 创建成功: bool "是否成功")

func main() {
    
    //desc: 判断条件说明
    if 条件变量 {
        //desc: 条件为真时的操作说明
        结果 := step1(参数)
        // 处理结果
    }
}
```

## 代码生成指导原则

### 1. 根据函数签名生成步骤定义
- 分析函数签名中的参数类型和名称
- 分析返回值类型和名称
- 动态工作流：生成 `函数名(参数类型 参数名)` 格式的步骤定义
- 静态工作流：生成 `函数名[用例ID]` 格式的步骤定义
- **每个步骤定义前必须添加 `//desc: 描述内容`** - 这是强制性的
- **禁止使用 `var (step1 = ...)` 批量声明格式**
- **返回值必须使用 `-> (变量名: 类型 "描述", ...)` 格式**

### 2. 根据业务逻辑生成主函数
- 按照业务流程顺序调用步骤
- 根据步骤定义的返回值数量正确接收返回值
- 动态工作流：接收所有返回值，如 `result := step1(input["参数"])`
- 静态工作流：接收所有返回值，如 `cost := step2()`
- **不需要错误检查，执行引擎会自动处理**
- **每个主要语句前必须添加 `//desc: 描述内容`** - 这是强制性的

### 3. 选择合适的模式
- 动态工作流：适用于参数化流程，使用 `(参数列表)` 定义参数，需要传递具体参数
- 静态工作流：适用于固定流程，使用 `[用例ID]` 引用预定义用例，参数从用例中获取

### 4. 错误处理最佳实践
- **不需要手动错误处理，执行引擎会自动处理**
- **通过 `{err_continue: true}` 控制错误行为**
- **专注于业务逻辑，让执行引擎处理技术细节**

### 5. 变量命名规范
- 使用有意义的变量名
- 支持中文变量名
- 返回值变量使用描述性名称

### 6. 条件判断生成规范
- 条件判断语句前必须添加 `//desc:` 注释说明判断逻辑
- 条件判断中的变量会自动声明，无需提前声明
- **条件判断中的步骤调用不需要错误处理，执行引擎会自动处理**
- 条件判断可以嵌套，但要注意变量作用域
- 条件判断的示例模式：
  ```go
  //desc: 判断条件说明
  if 条件变量 {
      //desc: 条件为真时的操作说明
      结果变量 := step(参数)
      // 处理结果
  }
  ```

## 注意事项

1. **语法严格性**：严格按照语法规则生成代码，避免语法错误
2. **错误处理**：**不需要手动错误处理，执行引擎会自动处理**
3. **描述注释（强制性）**：**每个步骤定义和主要语句都必须有 `//desc:` 描述注释，这是强制性的，不能省略**
4. **变量作用域**：确保变量在使用前已定义
5. **类型匹配**：确保参数类型与函数签名匹配
6. **返回值匹配**：确保接收的返回值数量与步骤定义中的返回值数量一致
7. **中文支持**：支持中文变量名和描述，但保持代码结构清晰
8. **静态工作流**：使用 `[用例ID]` 格式，用例ID用于引用预定义的测试用例或配置
9. **动态工作流**：使用 `(参数列表)` 格式，参数需要从 input 变量或前一步的返回值中获取
10. **条件判断**：条件判断语句前必须添加 `//desc:` 注释，条件中的变量会自动声明，无需提前声明
11. **步骤定义格式**：禁止使用 `var (step1 = ...)` 批量声明，必须逐个定义每个步骤
12. **打印功能**：已移除打印功能支持，执行引擎会自动处理日志记录
13. **返回值格式**：必须使用 `-> (变量名: 类型 "描述", ...)` 格式，禁止使用 `-> (类型 变量名, ...)` 格式
14. **执行引擎**：**专注于业务逻辑，让执行引擎处理错误、日志、重试等技术细节**

通过遵循本指南，大模型可以准确生成符合规范的工作流编排代码，实现复杂的业务流程自动化。

**再次强调：`//desc:` 描述注释是强制性的，每个步骤定义和主要语句都必须包含，这是生成有效工作流代码的基本要求。**
